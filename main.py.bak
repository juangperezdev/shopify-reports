import os
import requests
import json
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from datetime import datetime, timedelta, timezone
from dotenv import load_dotenv
from fpdf import FPDF
from collections import defaultdict

# 1. Cargar variables de entorno
load_dotenv()

# Configuraci√≥n de las tiendas basada en el .env
SHOPS = [
    {
        "name": os.getenv("SHOP1_NAME"),
        "url": os.getenv("SHOP1_URL"),
        "token": os.getenv("SHOP1_TOKEN")
    },
    {
        "name": os.getenv("SHOP2_NAME"),
        "url": os.getenv("SHOP2_URL"),
        "token": os.getenv("SHOP2_TOKEN")
    },
    {
        "name": os.getenv("SHOP3_NAME"),
        "url": os.getenv("SHOP3_URL"),
        "token": os.getenv("SHOP3_TOKEN")
    }
]

class ShopifyFetcher:
    def __init__(self, shop_config):
        self.shop = shop_config
        self.headers = {
            "X-Shopify-Access-Token": self.shop['token'],
            "Content-Type": "application/json"
        }
        self.base_url = f"https://{self.shop['url']}/admin/api/2025-10"
        self.graphql_url = f"{self.base_url}/graphql.json"

    def _get_rest_data(self, endpoint, params=None):
        url = f"{self.base_url}/{endpoint}"
        response = requests.get(url, headers=self.headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            print(f"Error en {self.shop['name']} ({endpoint}): {response.status_code} - {response.text}")
            return None
            
    def get_shop_timezone(self):
        """Obtiene la zona horaria de la tienda"""
        data = self._get_rest_data("shop.json")
        if data and 'shop' in data:
            return data['shop']['iana_timezone']
        return 'UTC'
    
    def _execute_graphql(self, query):
        """Ejecuta query GraphQL para Analytics"""
        response = requests.post(self.graphql_url, json={'query': query}, headers=self.headers)
        if response.status_code == 200:
            return response.json()
        else:
            print(f"Error GraphQL en {self.shop['name']}: {response.status_code} - {response.text}")
            return None

    def get_orders_for_period(self, target_date=None, end_date=None, days_ago=None):
        """
        Obtiene √≥rdenes para un per√≠odo espec√≠fico.
        Puede ser un d√≠a √∫nico (target_date) o un rango (target_date a end_date).
        """
        try:
            import pytz
        except ImportError:
            # Fallback si no est√° instalado pytz, usar UTC
            print("  ‚ö†Ô∏è  Librer√≠a 'pytz' no instalada. Usando UTC por defecto.")
            timezone_str = 'UTC'
            tz = timezone.utc
        else:
            timezone_str = self.get_shop_timezone()
            try:
                tz = pytz.timezone(timezone_str)
            except:
                tz = timezone.utc
            
        # Determinar inicio y fin del rango
        if end_date:
            # Rango de fechas
            start_date = target_date
            final_date = end_date
        elif target_date:
            # Un solo d√≠a
            start_date = target_date
            final_date = target_date
        else:
            # Fallback legacy
            start_date = datetime.now().date() - timedelta(days=days_ago or 1)
            final_date = start_date

        # Calcular fechas en la zona horaria de la tienda
        naive_start = datetime.combine(start_date, datetime.min.time())
        naive_end = datetime.combine(final_date, datetime.max.time())
        
        if hasattr(tz, 'localize'):
            start_local = tz.localize(naive_start)
            end_local = tz.localize(naive_end)
        else:
            start_local = naive_start.replace(tzinfo=tz)
            end_local = naive_end.replace(tzinfo=tz)
        
        # Convertir a UTC para la API
        start_utc = start_local.astimezone(timezone.utc)
        end_utc = end_local.astimezone(timezone.utc)
        
        params = {
            "status": "any",
            "created_at_min": start_utc.isoformat(),
            "created_at_max": end_utc.isoformat(),
            "limit": 250 
        }
        
        print(f"  üìÖ Consultando {timezone_str}: {start_date} - {final_date}")
        
        data = self._get_rest_data("orders.json", params)
        if data and 'orders' in data:
            orders_count = len(data['orders'])
            print(f"  ‚ÑπÔ∏è  Encontradas {orders_count} √≥rdenes para {start_local.strftime('%Y-%m-%d')}")
            return data['orders']
        else:
            print(f"  ‚ö†Ô∏è  No se encontraron √≥rdenes para {start_local.strftime('%Y-%m-%d')}")
        return []
    
    def get_orders_for_date(self, date_obj, end_date_obj=None):
        """Obtiene √≥rdenes de una fecha o rango espec√≠fico"""
        return self.get_orders_for_period(target_date=date_obj, end_date=end_date_obj)

    def get_previous_period_orders(self, start_date, end_date=None):
        """
        Obtiene √≥rdenes del per√≠odo anterior equivalente.
        Si es un d√≠a, devuelve el d√≠a anterior.
        Si es un rango (ej: 7 d√≠as), devuelve los 7 d√≠as previos al rango.
        """
        if end_date:
            # Calcular duraci√≥n del rango
            duration = (end_date - start_date).days + 1
            prev_end = start_date - timedelta(days=1)
            prev_start = prev_end - timedelta(days=duration - 1)
            return self.get_orders_for_period(target_date=prev_start, end_date=prev_end)
        else:
            # Un solo d√≠a
            previous_day = start_date - timedelta(days=1)
            return self.get_orders_for_period(target_date=previous_day)
    
    def get_abandoned_checkouts(self, target_date):
        """Obtiene carritos abandonados de una fecha espec√≠fica"""
        try:
            import pytz
        except ImportError:
            timezone_str = 'UTC'
            tz = timezone.utc
        else:
            timezone_str = self.get_shop_timezone()
            try:
                tz = pytz.timezone(timezone_str)
            except:
                tz = timezone.utc
        
        # Calcular rango del d√≠a
        naive_start = datetime.combine(target_date, datetime.min.time())
        naive_end = datetime.combine(target_date, datetime.max.time())
        
        if hasattr(tz, 'localize'):
            start_local = tz.localize(naive_start)
            end_local = tz.localize(naive_end)
        else:
            start_local = naive_start.replace(tzinfo=tz)
            end_local = naive_end.replace(tzinfo=tz)
        
        start_utc = start_local.astimezone(timezone.utc)
        end_utc = end_local.astimezone(timezone.utc)
        
        params = {
            "created_at_min": start_utc.isoformat(),
            "created_at_max": end_utc.isoformat(),
            "status": "open",  # Solo carritos abandonados
            "limit": 250
        }
        
        data = self._get_rest_data("checkouts.json", params)
        if data and 'checkouts' in data:
            checkouts = data['checkouts']
            print(f"  üõí Encontrados {len(checkouts)} carritos abandonados")
            return checkouts
        return []
    
    def get_analytics_by_channel(self, days_ago=1):
        """Obtiene sesiones y conversi√≥n por canal usando ShopifyQL"""
        # TEMPORALMENTE DESHABILITADO - ShopifyQL no est√° disponible en plan b√°sico
        print(f"  ‚ÑπÔ∏è  Analytics por canal no disponible (requiere Shopify Plus)")
        return {}
    
    def get_overall_analytics(self, days_ago=1):
        """Obtiene m√©tricas generales del d√≠a"""
        # TEMPORALMENTE DESHABILITADO - ShopifyQL no disponible en plan b√°sico
        print(f"  ‚ÑπÔ∏è  Analytics generales no disponible (requiere Shopify Plus)")
        return {'sessions': 0, 'sales': 0.0, 'orders': 0, 'conversion_rate': 0.0}

    def process_daily_stats(self, orders, is_range=False, start_date=None, end_date=None):
        """Calcula totales basados en la lista de √≥rdenes"""
        total_sales = 0.0
        total_orders = len(orders)
        
        if is_range and start_date and end_date:
            # Para rangos, agrupar por d√≠a
            num_days = (end_date - start_date).days + 1
            daily_counts = [0] * num_days
        else:
            # Para un solo d√≠a, agrupar por hora
            hourly_counts = [0] * 24
            daily_counts = None
        
        channels = defaultdict(lambda: {'count': 0, 'sales': 0.0})

        for order in orders:
            # Ventas (usamos total_price)
            try:
                total_sales += float(order.get('total_price', 0))
            except:
                pass
    
            # Agrupar por hora o por d√≠a seg√∫n el caso
            created_at = datetime.fromisoformat(order['created_at'].replace('Z', '+00:00'))
            
            if is_range and start_date and end_date:
                # Agrupar por d√≠a
                order_date = created_at.date()
                day_index = (order_date - start_date).days
                if 0 <= day_index < len(daily_counts):
                    daily_counts[day_index] += 1
            else:
                # Agrupar por hora
                hour = created_at.hour
                if 0 <= hour < 24:
                    hourly_counts[hour] += 1

            # Atribuci√≥n mejorada: usamos referring_site para ver los canales de marketing reales
            referring_site = order.get('referring_site', '')
            source_name = order.get('source_name', '')
            
            # Determinar el canal y tipo basado en referring_site
            channel_type = 'unknown'
            if referring_site:
                # Limpiar y categorizar
                if 'google' in referring_site.lower():
                    channel = 'Google Search'
                    channel_type = 'organic' if 'search' in referring_site.lower() or '/url?' in referring_site else 'unknown'
                elif 'facebook' in referring_site.lower() or 'fb' in referring_site.lower():
                    channel = 'Facebook'
                    channel_type = 'paid'  # Facebook suele ser tr√°fico pago
                elif 'instagram' in referring_site.lower():
                    channel = 'Instagram'
                    channel_type = 'paid'
                elif 'tiktok' in referring_site.lower():
                    channel = 'TikTok'
                    channel_type = 'paid'
                elif 'pinterest' in referring_site.lower():
                    channel = 'Pinterest'
                    channel_type = 'organic'
                elif 'youtube' in referring_site.lower():
                    channel = 'YouTube'
                    channel_type = 'organic'
                elif 'twitter' in referring_site.lower() or 't.co' in referring_site.lower():
                    channel = 'Twitter/X'
                    channel_type = 'organic'
                else:
                    # Mostrar el dominio limpio
                    channel = referring_site.replace('https://', '').replace('http://', '').split('/')[0]
                    channel_type = 'unknown'
            else:
                # Sin referring_site = tr√°fico directo o app
                if source_name == 'web':
                    channel = 'Direct'
                    channel_type = 'direct'
                elif source_name in ['iphone', 'android', 'mobile_app']:
                    channel = f'App ({source_name.title()})'
                    channel_type = 'direct'
                else:
                    channel = source_name if source_name else 'Direct'
                    channel_type = 'direct'
            
            # Guardar con tipo
            if channel not in channels:
                channels[channel] = {'count': 0, 'sales': 0.0, 'type': channel_type}
            
            channels[channel]['count'] += 1
            try:
                channels[channel]['sales'] += float(order.get('total_price', 0))
            except:
                pass



        return {
            "summary": {
                "Ventas": f"${total_sales:.2f}",
                "Ordenes": total_orders,
                "Ticket Prom": f"${(total_sales/total_orders):.2f}" if total_orders > 0 else "$0.00"
            },
            "hourly_orders": hourly_counts if not is_range else None,
            "daily_orders": daily_counts if is_range else None,
            "attribution": channels,
            "is_range": is_range,
            "start_date": start_date,
            "end_date": end_date
        }
    
    def compare_periods(self, current_stats, previous_stats):
        """Compara dos per√≠odos y calcula % de cambio"""
        def calc_change(current, previous):
            if previous == 0:
                return 0 if current == 0 else 100
            return ((current - previous) / previous) * 100
        
        current_sales = float(current_stats['summary']['Ventas'].replace('$', '').replace(',', ''))
        previous_sales = float(previous_stats['summary']['Ventas'].replace('$', '').replace(',', ''))
        
        current_orders = current_stats['summary']['Ordenes']
        previous_orders = previous_stats['summary']['Ordenes']
        
        sales_change = calc_change(current_sales, previous_sales)
        orders_change = calc_change(current_orders, previous_orders)
        
        return {
            'sales_change': sales_change,
            'orders_change': orders_change
        }

def create_chart(data_points, store_name, is_range=False, start_date=None, end_date=None):
    """Genera y guarda el gr√°fico PNG de √ìrdenes por Hora o por D√≠a"""
    plt.figure(figsize=(10, 3))
    
    if is_range:
        # Gr√°fico por d√≠as
        num_days = len(data_points)
        days = range(num_days)
        plt.bar(days, data_points, color='#008060', alpha=0.7)
        plt.title(f"Orders by Day - {store_name}", fontsize=10)
        plt.xlabel("Day")
        plt.ylabel("Order Count")
        plt.grid(True, axis='y', linestyle='--', alpha=0.3)
        
        # Etiquetas de d√≠as con fechas
        if num_days <= 15:
            # Mostrar todas las fechas si hay pocas
            day_labels = [(start_date + timedelta(days=i)).strftime('%m/%d') for i in range(num_days)]
            plt.xticks(days, day_labels, rotation=45, ha='right')
        else:
            # Mostrar solo algunas fechas si hay muchas
            step = max(1, num_days // 10)
            plt.xticks(days[::step])
    else:
        # Gr√°fico por horas
        hours = range(len(data_points))
        plt.bar(hours, data_points, color='#008060', alpha=0.7)
        plt.title(f"Orders by Hour (Yesterday) - {store_name}", fontsize=10)
        plt.xlabel("Hour of day")
        plt.ylabel("Order Count")
        plt.grid(True, axis='y', linestyle='--', alpha=0.3)
        plt.xticks(hours[::2])  # Mostrar cada 2 horas
    
    filename = f"temp_chart_{store_name.replace(' ', '_')}.png"
    plt.savefig(filename, dpi=100, bbox_inches='tight')
    plt.close()
    return filename

class PDFReport(FPDF):
    def __init__(self, report_date=None):
        super().__init__()
        self.report_date = report_date
        
    def header(self):
        # Logo (si existe)
        logo_path = 'static/logo.jpg'
        if os.path.exists(logo_path):
            self.image(logo_path, x=10, y=8, w=30)  # Logo en la esquina superior izquierda
        
        if self.report_date:
            # T√≠tulo principal: Fecha del reporte
            self.set_font('Arial', 'B', 16)
            if isinstance(self.report_date, str):
                formatted_date = self.report_date
            else:
                formatted_date = self.report_date.strftime('%B %d, %Y')
            self.cell(0, 10, formatted_date, 0, 1, 'C')
            
            # Subt√≠tulo: Fecha de generaci√≥n
            self.set_font('Arial', '', 9)
            self.set_text_color(128, 128, 128)
            gen_date = datetime.now().strftime('%B %d, %Y at %H:%M')
            self.cell(0, 5, f'Generated on: {gen_date}', 0, 1, 'C')
            self.set_text_color(0, 0, 0)
            self.ln(18)  # M√°s espacio para evitar que el t√≠tulo de la tienda pise el logo

    def add_store_section(self, store_data):
        # T√≠tulo Tienda
        self.set_fill_color(240, 240, 240)
        self.set_font('Arial', 'B', 14)
        self.cell(0, 12, f" {store_data['name']}", 0, 1, 'L', 1)
        self.ln(2)
        
        # Leyenda Narrativa (estilo Shopify)
        if 'narrative' in store_data:
            self.set_font('Arial', '', 10)
            self.set_text_color(80, 80, 80)
            self.multi_cell(0, 5, store_data['narrative'])
            self.set_text_color(0, 0, 0)
            self.ln(3)

        # M√©tricas Clave con % de Cambio
        self.set_font('Arial', 'B', 11)
        metrics = store_data['stats']['summary']
        comparison = store_data.get('comparison', {})
        
        # Fila 1: Ventas y √ìrdenes
        col_w = 95
        self.set_fill_color(250, 250, 250)
        
        # Ventas
        self.cell(col_w, 10, f"Total Sales: {metrics['Ventas']}", 1, 0, 'L', 1)
        if 'sales_change' in comparison:
            change = comparison['sales_change']
            sign = '+' if change >= 0 else ''
            self.set_text_color(0, 128, 0) if change >= 0 else self.set_text_color(255, 0, 0)
            self.cell(col_w, 10, f"  {sign}{change:.1f}%", 1, 1, 'L', 1)
            self.set_text_color(0, 0, 0)
        else:
            self.cell(col_w, 10, "", 1, 1)
        
        # √ìrdenes  
        self.set_fill_color(250, 250, 250)
        self.cell(col_w, 10, f"Orders: {metrics['Ordenes']}", 1, 0, 'L', 1)
        if 'orders_change' in comparison:
            change = comparison['orders_change']
            sign = '+' if change >= 0 else ''
            self.set_text_color(0, 128, 0) if change >= 0 else self.set_text_color(255, 0, 0)
            self.cell(col_w, 10, f"  {sign}{change:.1f}%", 1, 1, 'L', 1)
            self.set_text_color(0, 0, 0)
        else:
            self.cell(col_w, 10, "", 1, 1)
        
        # Ticket Promedio (todo en primera columna, en rojo)
        self.set_fill_color(250, 250, 250)
        self.set_text_color(255, 0, 0)  # Rojo
        self.cell(col_w, 10, f"Avg Ticket: {metrics['Ticket Prom']}", 1, 0, 'L', 1)
        self.set_text_color(0, 0, 0)  # Volver a negro
        self.cell(col_w, 10, "", 1, 1)  # Segunda columna vac√≠a
        
        self.ln(5)

        # Gr√°fico
        if store_data['chart_file']:
            self.image(store_data['chart_file'], x=10, w=190)
            self.ln(2)

        # Tabla Atribuci√≥n (Canales de Marketing)
        self.set_font('Arial', 'B', 10)
        self.cell(0, 8, "Attribution - Marketing Channels", 0, 1)
        self.ln(2)
        
        # Header Tabla (simplificada)
        self.set_fill_color(245, 245, 245)
        self.set_font('Arial', 'B', 9)
        col_w = [80, 40, 50]  # Channel, Orders, Sales
        headers = ["Channel", "Orders", "Sales"]
        for i, h in enumerate(headers):
            self.cell(col_w[i], 7, h, 1, 0, 'C', 1)
        self.ln()

        # Filas Tabla
        self.set_font('Arial', '', 9)
        self.set_fill_color(255, 255, 255)
        attribution_data = store_data['stats']['attribution']
        
        if not attribution_data:
            self.cell(sum(col_w), 7, "No order data", 1, 1, 'C')
        else:
            # Ordenar por ventas (mayor a menor)
            sorted_channels = sorted(attribution_data.items(), key=lambda x: x[1]['sales'], reverse=True)
            
            for channel_name, data in sorted_channels:
                orders = data.get('orders', data.get('count', 0))
                sales = data.get('sales', 0.0)
                
                # Alternar color de fondo
                self.set_fill_color(250, 250, 250)
                
                self.cell(col_w[0], 7, str(channel_name)[:35], 1, 0, 'L', 1)
                self.cell(col_w[1], 7, str(orders), 1, 0, 'C', 1)
                self.cell(col_w[2], 7, f"${sales:.2f}", 1, 1, 'R', 1)
        
        self.ln(10)
        
        # Secci√≥n de Carritos Abandonados
        self.set_font('Arial', 'B', 10)
        self.cell(0, 8, "Abandoned Carts", 0, 1)
        self.ln(2)
        
        if 'abandoned_carts' in store_data and store_data['abandoned_carts']:
            carts_data = store_data['abandoned_carts']
            total_carts = carts_data['count']
            total_value = carts_data['total_value']
            avg_value = carts_data['avg_value']
            
            # M√©tricas de carritos abandonados
            self.set_fill_color(250, 250, 250)
            self.set_font('Arial', 'B', 9)
            
            col_w_carts = 63  # 3 columnas iguales
            
            self.cell(col_w_carts, 10, f"Total Carts: {total_carts}", 1, 0, 'L', 1)
            self.cell(col_w_carts, 10, f"Total Value: ${total_value:.2f}", 1, 0, 'L', 1)
            self.cell(col_w_carts, 10, f"Avg Value: ${avg_value:.2f}", 1, 1, 'L', 1)
            
            self.ln(5)
            
            # Lista de carritos en p√°gina separada
            if 'list' in carts_data and carts_data['list']:
                self.add_page()
                
                # T√≠tulo de la p√°gina de carritos
                self.set_font('Arial', 'B', 14)
                self.cell(0, 10, f"Abandoned Carts Detail - {store_data['name']}", 0, 1, 'C')
                self.ln(5)
                
                self.set_font('Arial', 'B', 8)
                self.set_fill_color(245, 245, 245)
                
                # Headers
                self.cell(110, 6, "Customer Email", 1, 0, 'L', 1)
                self.cell(40, 6, "Value", 1, 0, 'R', 1)
                self.cell(40, 6, "Time", 1, 1, 'C', 1)
                
                # Filas
                self.set_font('Arial', '', 8)
                self.set_fill_color(255, 255, 255)
                
                # Mostrar TODOS los carritos (sin l√≠mite)
                for cart in carts_data['list']:
                    email = cart['email']
                    val = cart['value']
                    # Extraer hora de la fecha ISO
                    try:
                        time_str = cart['date'].split('T')[1][:5]
                    except:
                        time_str = "--:--"
                        
                    self.cell(110, 6, email, 1, 0, 'L', 1)
                    self.cell(40, 6, f"${val:.2f}", 1, 0, 'R', 1)
                    self.cell(40, 6, time_str, 1, 1, 'C', 1)
            
            self.ln(5)
        else:
            self.set_font('Arial', '', 9)
            self.cell(0, 10, "No abandoned carts found for this date.", 0, 1, 'L')
            self.ln(5)

# --- EJECUCI√ìN PRINCIPAL ---

def generate_report_for_date(target_date_str, end_date_str=None):
    """Genera el reporte para una fecha o rango espec√≠fico (YYYY-MM-DD)"""
    try:
        target_date = datetime.strptime(target_date_str, '%Y-%m-%d').date()
        
        # CASO 1: RANGO DE FECHAS
        if end_date_str and end_date_str.strip():
            end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()
            print(f"\nüîπ MODO RANGO: Generando reporte para {target_date} - {end_date}...")
            return _generate_range_report(target_date, end_date)
        
        # CASO 2: D√çA √öNICO  
        else:
            print(f"\nüîπ MODO D√çA √öNICO: Generando reporte para {target_date}...")
            return _generate_single_day_report(target_date)
            
    except ValueError as e:
        print(f"Error de formato de fecha: {e}")
        return None
    except Exception as e:
        print(f"Error inesperado: {e}")
        import traceback
        traceback.print_exc()
        return None

def _generate_single_day_report(target_date):
    """Genera reporte de un d√≠a con gr√°fico por hora y carritos abandonados"""
    report_title_date = target_date
    filename_date = target_date.strftime('%Y-%m-%d')
    
    collected_data = []
    
    for shop_conf in SHOPS:
        if not shop_conf["token"]: continue
        
        print(f"Procesando {shop_conf['name']}...")
        fetcher = ShopifyFetcher(shop_conf)
        
        # Obtener √≥rdenes del d√≠a y del d√≠a anterior
        current_orders = fetcher.get_orders_for_date(target_date)
        previous_orders = fetcher.get_previous_period_orders(target_date)
        
        # Procesar estad√≠sticas (POR HORA para d√≠a √∫nico)
        current_stats = fetcher.process_daily_stats(current_orders, is_range=False)
        previous_stats = fetcher.process_daily_stats(previous_orders, is_range=False)
        
        # Obtener carritos abandonados (SOLO en modo d√≠a √∫nico)
        abandoned_checkouts = fetcher.get_abandoned_checkouts(target_date)
        abandoned_carts_data = None
        
        if abandoned_checkouts:
            total_value = sum(float(c.get('total_price', 0)) for c in abandoned_checkouts)
            avg_value = total_value / len(abandoned_checkouts) if abandoned_checkouts else 0
            
            carts_list = []
            for cart in abandoned_checkouts:
                carts_list.append({
                    'email': cart.get('email', 'No email'),
                    'value': float(cart.get('total_price', 0)),
                    'date': cart.get('created_at', '')
                })
            
            abandoned_carts_data = {
                'count': len(abandoned_checkouts),
                'total_value': total_value,
                'avg_value': avg_value,
                'list': carts_list
            }
        
        # Comparar per√≠odos
        comparison = fetcher.compare_periods(current_stats, previous_stats)
        
        # Generar gr√°fico POR HORA (24 barras)
        chart_path = create_chart(current_stats['hourly_orders'], shop_conf['name'], is_range=False)
        
        # Narrativa
        sales_val = current_stats['summary']['Ventas']
        orders_count = current_stats['summary']['Ordenes']
        sales_change = comparison['sales_change']
        orders_change = comparison['orders_change']
        sales_trend = "an increase" if sales_change >= 0 else "a decrease"
        orders_trend = "showing" if orders_change >= 0 else "with"
        
        narrative = (
            f"{shop_conf['name']} store generated total sales of {sales_val}, "
            f"{sales_trend} of {abs(sales_change):.0f}% compared to the previous day. "
            f"The store fulfilled {orders_count} orders, {orders_trend} "
            f"{'+' if orders_change >= 0 else ''}{orders_change:.0f}% change in order volume."
        )
        
        collected_data.append({
            "name": shop_conf['name'],
            "stats": current_stats,
            "comparison": comparison,
            "chart_file": chart_path,
            "narrative": narrative,
            "analytics": {'sessions': 0, 'conversion_rate': 0},
            "abandoned_carts": abandoned_carts_data  # INCLUIDO en d√≠a √∫nico
        })
    
    # Generar PDF
    if collected_data:
        pdf = PDFReport(report_date=report_title_date)
        pdf.add_page()
        
        for idx, data in enumerate(collected_data):
            if idx > 0:
                pdf.add_page()
            pdf.add_store_section(data)
            if os.path.exists(data['chart_file']):
                os.remove(data['chart_file'])
        
        filename = f"Reporte_Ventas_{filename_date}.pdf"
        pdf.output(filename)
        print(f"\n‚úÖ Reporte de d√≠a √∫nico generado: {filename}")
        return filename
    return None

def _generate_range_report(start_date, end_date):
    """Genera reporte de rango con gr√°fico por d√≠a y SIN carritos abandonados"""
    report_title_date = f"{start_date.strftime('%b %d')} - {end_date.strftime('%b %d, %Y')}"
    filename_date = f"{start_date.strftime('%Y-%m-%d')}_to_{end_date.strftime('%Y-%m-%d')}"
    
    collected_data = []
    
    for shop_conf in SHOPS:
        if not shop_conf["token"]: continue
        
        print(f"Procesando {shop_conf['name']}...")
        fetcher = ShopifyFetcher(shop_conf)
        
        # Obtener √≥rdenes del rango y del per√≠odo anterior
        current_orders = fetcher.get_orders_for_date(start_date, end_date)
        previous_orders = fetcher.get_previous_period_orders(start_date, end_date)
        
        # Procesar estad√≠sticas (POR D√çA para rangos)
        current_stats = fetcher.process_daily_stats(current_orders, is_range=True, start_date=start_date, end_date=end_date)
        
        # Calcular fechas del per√≠odo anterior
        duration = (end_date - start_date).days + 1
        prev_end = start_date - timedelta(days=1)
        prev_start = prev_end - timedelta(days=duration - 1)
        previous_stats = fetcher.process_daily_stats(previous_orders, is_range=True, start_date=prev_start, end_date=prev_end)
        
        # NO obtener carritos abandonados en modo rango
        abandoned_carts_data = None
        
        # Comparar per√≠odos
        comparison = fetcher.compare_periods(current_stats, previous_stats)
        
        # Generar gr√°fico POR D√çA
        chart_path = create_chart(current_stats['daily_orders'], shop_conf['name'], is_range=True, start_date=start_date, end_date=end_date)
        
        # Narrativa
        sales_val = current_stats['summary']['Ventas']
        orders_count = current_stats['summary']['Ordenes']
        sales_change = comparison['sales_change']
        orders_change = comparison['orders_change']
        sales_trend = "an increase" if sales_change >= 0 else "a decrease"
        orders_trend = "showing" if orders_change >= 0 else "with"
        
        narrative = (
            f"{shop_conf['name']} store generated total sales of {sales_val}, "
            f"{sales_trend} of {abs(sales_change):.0f}% compared to the previous period. "
            f"The store fulfilled {orders_count} orders, {orders_trend} "
            f"{'+' if orders_change >= 0 else ''}{orders_change:.0f}% change in order volume."
        )
        
        collected_data.append({
            "name": shop_conf['name'],
            "stats": current_stats,
            "comparison": comparison,
            "chart_file": chart_path,
            "narrative": narrative,
            "analytics": {'sessions': 0, 'conversion_rate': 0},
            "abandoned_carts": None  # EXCLUIDO en rangos
        })
    
    # Generar PDF
    if collected_data:
        pdf = PDFReport(report_date=report_title_date)
        pdf.add_page()
        
        for idx, data in enumerate(collected_data):
            if idx > 0:
                pdf.add_page()
            pdf.add_store_section(data)
            if os.path.exists(data['chart_file']):
                os.remove(data['chart_file'])
        
        filename = f"Reporte_Ventas_{filename_date}.pdf"
        pdf.output(filename)
        print(f"\n‚úÖ Reporte de rango generado: {filename}")
        return filename
    return None

if __name__ == "__main__":
    # Por defecto genera el reporte de ayer
    yesterday = datetime.now() - timedelta(days=1)
    generate_report_for_date(yesterday.strftime('%Y-%m-%d'))
    """Genera el reporte para una fecha o rango espec√≠fico (YYYY-MM-DD)"""
    try:
        target_date = datetime.strptime(target_date_str, '%Y-%m-%d').date()
        end_date = None
        
        if end_date_str:
            end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()
            print(f"\nIniciando generaci√≥n de reporte para rango: {target_date} - {end_date}...")
            report_title_date = f"{target_date.strftime('%b %d')} - {end_date.strftime('%b %d, %Y')}"
            filename_date = f"{target_date.strftime('%Y-%m-%d')}_to_{end_date.strftime('%Y-%m-%d')}"
        else:
            print(f"\nIniciando generaci√≥n de reporte para {target_date}...")
            report_title_date = target_date
            filename_date = target_date.strftime('%Y-%m-%d')

        collected_data = []
        
        # 1. Obtener datos de cada tienda
        for shop_conf in SHOPS:
            if not shop_conf["token"]: continue 
            
            print(f"Procesando {shop_conf['name']}...")
            fetcher = ShopifyFetcher(shop_conf)
            
            # Obtener √≥rdenes de DOS per√≠odos (fecha seleccionada y d√≠a anterior)
            current_orders = fetcher.get_orders_for_date(target_date, end_date)
            
            # Calcular per√≠odo anterior equivalente
            previous_orders = fetcher.get_previous_period_orders(target_date, end_date)
            
            # Procesar estad√≠sticas de √≥rdenes
            current_stats = fetcher.process_daily_stats(current_orders, is_range=(end_date is not None), start_date=target_date, end_date=end_date)
            previous_stats = fetcher.process_daily_stats(previous_orders, is_range=(end_date is not None), start_date=target_date if not end_date else (target_date - timedelta(days=(end_date - target_date).days + 1)), end_date=target_date - timedelta(days=1) if not end_date else target_date - timedelta(days=1))
            
            # Obtener Analytics (sesiones, conversi√≥n)
            # ... (c√≥digo existente de analytics) ...
            
            # Obtener carritos abandonados - SOLO para d√≠as √∫nicos, NO para rangos
            abandoned_checkouts = None
            abandoned_carts_data = None
            
            if not end_date:
                # Solo procesar carritos abandonados si es un d√≠a √∫nico
                abandoned_checkouts = fetcher.get_abandoned_checkouts(target_date) 
            
            
            if abandoned_checkouts:
                total_value = sum(float(c.get('total_price', 0)) for c in abandoned_checkouts)
                avg_value = total_value / len(abandoned_checkouts) if abandoned_checkouts else 0
                
                # Preparar lista de detalles
                carts_list = []
                for cart in abandoned_checkouts:
                    carts_list.append({
                        'email': cart.get('email', 'No email'),
                        'value': float(cart.get('total_price', 0)),
                        'date': cart.get('created_at', '')
                    })
                
                abandoned_carts_data = {
                    'count': len(abandoned_checkouts),
                    'total_value': total_value,
                    'avg_value': avg_value,
                    'list': carts_list  # Lista detallada
                }
            
            # Comparar per√≠odos
            comparison = fetcher.compare_periods(current_stats, previous_stats)
            
            # Generar gr√°fico de √≥rdenes (por hora o por d√≠a)
            chart_data = current_stats.get('daily_orders') if end_date else current_stats.get('hourly_orders')
            chart_path = create_chart(chart_data, shop_conf['name'], is_range=(end_date is not None), start_date=target_date, end_date=end_date)
            
            # Generar leyenda narrativa estilo Shopify
            sales_val = current_stats['summary']['Ventas']
            orders_count = current_stats['summary']['Ordenes']
            
            sales_change = comparison['sales_change']
            orders_change = comparison['orders_change']
            
            sales_trend = "an increase" if sales_change >= 0 else "a decrease"
            orders_trend = "showing" if orders_change >= 0 else "with"
            
            narrative = (
                f"{shop_conf['name']} store generated total sales of {sales_val}, "
                f"{sales_trend} of {abs(sales_change):.0f}% compared to the previous day. "
                f"The store fulfilled {orders_count} orders, {orders_trend} "
                f"{'+' if orders_change >= 0 else ''}{orders_change:.0f}% change in order volume."
            )
            
            collected_data.append({
                "name": shop_conf['name'],
                "stats": current_stats,
                "comparison": comparison,
                "chart_file": chart_path,
                "narrative": narrative,
                "analytics": {'sessions': 0, 'conversion_rate': 0},  # Placeholder
                "abandoned_carts": abandoned_carts_data
            })

        # 2. Generar PDF
        if collected_data:
            pdf = PDFReport(report_date=report_title_date)
            pdf.add_page()
            
            for idx, data in enumerate(collected_data):
                # Nueva p√°gina para cada tienda (excepto la primera)
                if idx > 0:
                    pdf.add_page()
                    
                pdf.add_store_section(data)
                
                if os.path.exists(data['chart_file']):
                    os.remove(data['chart_file'])
                
            filename = f"Reporte_Ventas_{filename_date}.pdf"
            pdf.output(filename)
            print(f"\n¬°√âxito! Reporte generado: {filename}")
            return filename
            
    except ValueError as e:
        print(f"Error de formato de fecha: {e}")
        return None
    except Exception as e:
        print(f"Error inesperado: {e}")
        import traceback
        traceback.print_exc()
        return None

if __name__ == "__main__":
    # Por defecto genera el reporte de ayer
    yesterday = datetime.now() - timedelta(days=1)
    generate_report_for_date(yesterday.strftime('%Y-%m-%d'))